1. Arquitectura general del sistema
-----------------------------------

### 1.1 Visión global

Sistema compuesto por:

- **Motor de IA (Z.ai GLM-4.5/4.6)** como cerebro de razonamiento y orquestación de tools vía API y MCPs. [docs.z](https://docs.z.ai/guides/llm/glm-4.5)
- **Backend orquestador** (servicio propio) que expone herramientas al modelo:  
  - MCP servers (Caido, DevTools, CLI tools, Git).  
  - Job runner y colas para tareas largas (nmap, schemathesis, etc.).  
- **Caido** como proxy central HTTP(S)/WebSocket + workflows de automatización y issue tracking. [caido](https://caido.io)
- **Navegador automatizado** usando Chrome DevTools MCP para navegación, auth compleja y análisis dinámico. [developer.chrome](https://developer.chrome.com/blog/chrome-devtools-mcp)
- **Herramientas externas** (CLI/APIs) para recon, discovery y test de vulnerabilidades críticas (nmap, subfinder, whatweb, schemathesis, etc.). [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)

(Supuesto añadido) El backend se despliega como microservicio único (monolito modular) con módulos internos para simplificar.

### 1.2 Componentes principales

1. **Z.ai Agent Layer**
   - Definición de “tools” Z.ai que envuelven llamadas a:
     - MCP Caido.
     - MCP DevTools.
     - MCP CLI-Security.
     - MCP Git/Code.
   - Política de razonamiento (Thinking mode) para planificación multi‑paso, selección de herramientas, correlación de hallazgos. [z](https://z.ai/blog/glm-4.5)

2. **Backend Orquestador**
   - API REST interna para:
     - Crear/Lanzar “Pentest Sessions”.
     - Consultar estado y resultados.
   - Módulo MCP Gateway:
     - Implementa varios MCP servers según especificación oficial. [modelcontextprotocol](https://modelcontextprotocol.io/docs/develop/build-server)
   - Módulo Scheduler/Jobs:
     - Cola (ej. Redis) + workers para ejecutar herramientas pesadas con límites de concurrencia.
   - Módulo Storage:
     - DB (PostgreSQL) para:
       - Metadatos de sesiones, findings, PoCs.
       - Artefactos (requests, respuestas, outputs de herramientas).
   - Módulo Reporting:
     - Construcción de modelo de datos de reporte y exportación a Markdown/PDF.

3. **Caido**
   - Proxy HTTP(S)/WebSocket para:
     - Navegador de escritorio.
     - Emulador/dispositivo móvil configurado con proxy.  
   - Workflows para:
     - Recon pasivo y activo sobre tráfico. [caido](https://caido.io/features)
     - Generación automática de issues por patrones de vulnerabilidad.  
   - API/WebSocket (supuesto añadido) consumida por MCP Caido.

4. **Navegador + DevTools MCP**
   - Chrome ejecutándose en modo headless/no-headless.
   - MCP DevTools para:
     - Control de pestañas, navegación, relleno de formularios, click en elementos. [github](https://github.com/ChromeDevTools/chrome-devtools-mcp)
     - Captura de network logs, console, DOM snapshots.

5. **Herramientas externas**
   - Recon: nmap, subfinder, whatweb, httpx, amass (opcional).  
   - API/REST fuzzing: schemathesis para OpenAPI/GraphQL. [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)
   - Otras (supuesto añadido): nuclei, ffuf, dalfox, kxss, etc.

### 1.3 Modelo de comunicación

- **Z.ai ↔ Backend Orquestador**: HTTP/REST + WebSocket opcional para streaming de estados.
- **Z.ai ↔ MCP servers**: Model Context Protocol (JSON-RPC sobre stdio o TCP según implementación). [modelcontextprotocol](https://modelcontextprotocol.io/docs/develop/build-server)
- **Backend ↔ Caido**: HTTP API/WebSocket (supuesto añadido) + MCP Caido por encima.
- **Backend ↔ DevTools**: MCP DevTools (que a su vez habla con Chrome DevTools Protocol). [developer.chrome](https://developer.chrome.com/blog/chrome-devtools-mcp)
- **Backend ↔ Tools CLI**: ejecución local controlada por MCP CLI-Security (wrapper sobre procesos del sistema).
- **Backend ↔ DB/Storage**: conexión directa a PostgreSQL y almacenamiento de artefactos en FS/objeto.

### 1.4 Flujos de datos y contexto

- Todas las salidas de herramientas (nmap, Caido, DevTools, etc.) se almacenan en la DB con:
  - session_id, target_id, tool_id, timestamps, etiquetas (vuln_type, host, endpoint).  
- El agente Z.ai sólo ve resúmenes o vistas filtradas, enviados por tools (ej. “get_findings_summary”, “get_recent_issues”).  
- Caido mantiene tráfico bruto y issues; el backend sincroniza issues y metadatos vía MCP Caido. [caido](https://caido.io/features)
- MCP Git/Code entrega análisis de código y rutas críticas, que se etiquetan y guían los siguientes pasos dinámicos.

***

2. Integración con Z.ai y definición de tools
---------------------------------------------

### 2.1 Uso de Z.ai como cerebro

1. **Razonamiento y planificación**
   - Uso de GLM‑4.5/4.6 en modo “thinking” para:
     - Tomar requerimientos iniciales y generar plan de pentest (fases, herramientas, orden). [docs.z](https://docs.z.ai/guides/llm/glm-4.5)
     - Decidir qué herramienta disparar en cada momento, con parámetros concretos.
     - Evaluar resultados y redefinir el plan (loop de reflexión).

2. **Análisis de resultados**
   - Parsers de alto nivel como tools:
     - `parse_nmap_output`, `summarize_caido_issues`, `analyze_devtools_logs`, `correlate_findings`.
   - Z.ai consume outputs estructurados (JSON) y los convierte en:
     - Hipótesis de vulnerabilidades.
     - Recomendaciones de tests adicionales.
     - Texto de reporte técnico y ejecutivo.

### 2.2 Diseño de tools Z.ai (interfaces de alto nivel)

Cada tool Z.ai envuelve una llamada a un MCP o API interna. Ejemplos:

1. **Gestión de sesión**
   - `create_pentest_session(params)`  
     - Input: target, alcance, credenciales, tipo app (web/móvil/API), flags de agresividad.  
     - Output: session_id, plan inicial, límites.

   - `get_session_state(session_id)`  
     - Devuelve progreso por fase, hallazgos críticos abiertos, tiempo restante.

2. **Orquestación de recon**
   - `run_recon(session_id, recon_scope)`  
     - Internamente llama a MCP CLI-Security para subfinder, nmap, whatweb, httpx.  
   - `get_recon_results(session_id)`  
     - Devuelve hosts, puertos, tecnologías, rutas descubiertas.

3. **Interacción con Caido (via MCP Caido)**
   - `caido_list_projects()`, `caido_get_requests(filter)`, `caido_run_workflow(workflow_id, params)`, `caido_get_workflow_results(run_id)`.  
   - `caido_get_issues(session_id)` para importar findings desde el issue tracker de Caido. [caido](https://caido.io/features)

4. **DevTools / Navegación**
   - `devtools_run_flow(flow_definition)`:
     - Navegar a URL, realizar login, manejo de MFA si es posible, ejecución de scripts JS.
   - `devtools_get_network_log(filter)`, `devtools_get_console_errors()`. [github](https://github.com/ChromeDevTools/chrome-devtools-mcp)

5. **Test de vulnerabilidades OWASP críticas**
   - `test_injection(endpoint_descriptor)`  
   - `test_xss(endpoint_descriptor)`  
   - `test_ssrf(endpoint_descriptor)`  
   - `test_broken_auth(endpoint_descriptor, accounts)`  
   (Cada tool delega en MCP CLI-Security + Caido workflows adecuados).

6. **Reporting**
   - `build_report(session_id, options)`  
   - `export_report(session_id, format)` → Markdown, PDF.

### 2.3 Tipos de mensajes/estructuras

- Descriptor de endpoint:
  - `url`, `method`, `params`, `headers`, `auth_context_id`, `source` (Caido/DevTools/Reversing).
- Finding:
  - `id`, `vuln_type`, `title`, `description`, `evidence`, `impact`, `likelihood`, `severity`, `status`, `poc`, `recommendation`, `references`.

***

3. Integración con Caido, workflows y MCPs
------------------------------------------

### 3.1 Configuración de Caido como proxy

1. **Escenario web**
   - Navegador (usado por DevTools) configurado con proxy HTTP(S) apuntando a Caido (127.0.0.1:porta). [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)
   - Certificado CA de Caido instalado en el sistema / navegador para interceptar TLS.

2. **Escenario móvil**
   - Dispositivo/emulador Android/iOS con:
     - Proxy WiFi apuntando a IP del host con Caido.  
     - Certificado CA instalado como root (cuando sea posible) para HTTPS.  
   - (Supuesto añadido) Emuladores automatizables (Android Emulator/Genymotion) pueden ser controlados desde un componente externo, pero el tráfico siempre pasa por Caido.

3. **Uso de Workflows**
   - Workflows de Caido configurados para:
     - Etiquetar peticiones que cumplan reglas (ej. parámetros sospechosos, endpoints admin). [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)
     - Ejecutar payloads automatizados sobre ciertas rutas (fuzz limitado).  
     - Crear issues cuando se detectan patrones de respuesta anómalos. [caido](https://caido.io/features)

### 3.2 MCP Caido (supuesto añadido)

MCP server “caido-mcp” expone métodos:

1. `list_projects()`
   - Output: lista de proyectos con `id`, `name`, `scope`, `created_at`.

2. `select_project(project_id)`
   - Asocia la sesión actual con un proyecto Caido determinado.

3. `get_requests(filter)`
   - Filtros: host, path prefix, status_code, tag/workflow, time range.
   - Output: lista de requests con request/response completos y metadatos.

4. `run_workflow(workflow_id, params)`
   - Dispara un workflow sobre:
     - Un conjunto de requests históricos.
     - Nuevas URL generadas por el agente (ej. fuzzing de parámetros).

5. `get_workflow_results(run_id)`
   - Devuelve:
     - Requests procesados.
     - Issues creadas, etiquetas, severidad.

6. `get_issues(filter)`
   - Integración con issue tracker de Caido:
     - `title`, `description`, `request_id`, `severity`, `tags`. [caido](https://caido.io/features)

7. `create_issue(issue_payload)`
   - Permite al agente registrar hallazgos en Caido de forma centralizada.

### 3.3 MCP para DevTools

Basado en Chrome DevTools MCP público. [developer.chrome](https://developer.chrome.com/blog/chrome-devtools-mcp)

1. Métodos clave:
   - `open_page(url, context_id)`  
   - `evaluate_js(code, selector?, context_id)`  
   - `fill_input(selector, value, context_id)`  
   - `click(selector, context_id)`  
   - `wait_for(selector|event, timeout, context_id)`  
   - `get_network_events(filter, context_id)`  
   - `get_console_logs(context_id)`  
   - `capture_dom_snapshot(context_id)`  

2. Auth compleja:
   - Login clásico: automatizado con secuencia de `open_page`, `fill_input`, `click`, `wait_for`.  
   - 2FA/TOTP:
     - (Supuesto añadido) MCP DevTools + tool “totp_generator(secret)” en MCP CLI-Security para generar códigos TOTP.  
   - “Sign in with Google”:
     - Navegación por ventanas/pestañas emergentes y manejo de redirecciones; altamente dependiente de política de automatización de Google, no siempre fiable.

### 3.4 Otros MCPs

1. **MCP CLI-Security (supuesto añadido)**
   - Métodos genéricos:
     - `run_command(command_name, args, timeout, session_id)`  
     - Comandos permitidos con perfiles:
       - Recon: `subfinder`, `nmap`, `whatweb`, `httpx`.  
       - Web/API: `schemathesis`, `ffuf`, `nuclei`, `dalfox` (XSS), `kxss`.  
   - Devuelve stdout, stderr, exit_code, path a artefactos (JSON, HTML, etc.).

2. **MCP Git/Code (supuesto añadido)**
   - `list_repos()`, `list_branches(repo)`, `get_tree(repo, path)`, `get_file(repo, path)`  
   - `search_code(repo, query)` para localizar controladores, validaciones, middlewares.  
   - Tool de análisis:
     - `summarize_risks(code_snippet, language, context)` para guiar testing dinámico.

***

4. Flujo de operación “fully autonomous” paso a paso
----------------------------------------------------

### 4.1 Lanzamiento con un solo comando

Entrada a alto nivel:

- `LaunchPentestRequest`:
  - `target_base_url` / dominios.
  - `app_type` (web, móvil+API, API only).
  - `scope` (dominios, rutas, exclusiones).
  - `credentials` (lista de cuentas con roles, TOTP secret si aplica).
  - `time_budget`, `max_parallelism`, `safe_mode` (limitación de agresividad).
  - `environments` (prod/preprod), ventanas de horario permitidas.

El backend:

1. Crea `session_id`.
2. Configura:
   - Proyecto Caido dedicado y mapea scope. [caido](https://caido.io/features)
   - Contexto DevTools (perfiles, cookies iniciales si se proporcionan).
3. Invoca a Z.ai con `session_id` y parámetros para generar plan de alto nivel.

### 4.2 Configuración automática de entorno

1. **Proxy / Caido**
   - Verifica que Caido está disponible y crea proyecto (MCP Caido).  
   - Ajusta reglas de scope y exclusión. [caido](https://caido.io/features)

2. **DevTools**
   - Crea contexto de navegador para el target.  
   - Configura proxy del navegador hacia Caido (preconfig host-level).

3. **Móvil (si app_type incluye mobile)**
   - (Supuesto añadido) Usuario proporciona o APK/IPA o al menos endpoints conocidos de la app.  
   - El sistema guía al usuario para configurar el dispositivo/emulador con el proxy de Caido, pero las acciones del agente se centran en análisis del tráfico resultante.

### 4.3 Fase de recon (paralelizada)

Orquestada por Z.ai:

1. **DNS/Hosts**
   - `subfinder` sobre dominios del scope.  
2. **Puertos/Servicios**
   - `nmap` (top ports / scan moderado según safe_mode).  
3. **Fingerprinting tecnológico**
   - `whatweb`, `httpx` sobre hosts vivos. [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)
4. **Importación en DB**
   - MCP CLI-Security guarda outputs.  
5. **Plan refinado**
   - Z.ai analiza resultados (`get_recon_results`) y decide:
     - Priorizar hosts críticos, puertos HTTP/HTTPS, APIs.

### 4.4 Discovery y mapeo con Caido

1. **Crawling inicial**
   - Z.ai ordena a DevTools navegar el sitio:
     - Landing, login, secciones principales, rutas API invocadas.  
   - Todo el tráfico pasa por Caido, que construye sitemap y history. [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)

2. **Workflows de descubrimiento**
   - Workflows configurados para:
     - Detectar endpoints con parámetros sospechosos (id, user, redirect, url, callback).  
     - Respuestas con indicios de errores de servidor, trazas, mensajes SQL. [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)
   - MCP Caido `get_requests` para extraer endpoints relevantes.

3. **Clasificación de superficie**
   - Z.ai recibe lista de endpoints con metadatos (auth/no auth, métodos, parámetros) y los agrupa:
     - CRUD típico, endpoints de configuración, acciones administrativas, endpoints de redirección, endpoints internos.

### 4.5 Pruebas automáticas de OWASP críticas

#### 4.5.1 Injection (SQLi, NoSQLi, Command Injection a alto nivel)

Estrategia:

1. Selección de candidatos:
   - Parámetros detectados por Caido como query/path/body, especialmente en endpoints de lectura/escritura.  
2. Payloads:
   - Uso de herramientas (ej. sqlmap, nuclei templates) controladas por MCP CLI-Security (supuesto añadido).  
3. Validación “no falso positivo”:
   - Confirmar:
     - Cambios consistentes en la respuesta (time-based, error-based, boolean-based).  
     - Repetición de resultados con distintas semillas.  
4. PoC de alto nivel:
   - Ejemplo: petición HTTP reproducible con payload específico + descripción del impacto.

#### 4.5.2 XSS

1. Identificación:
   - Entradas reflejadas o almacenadas (DOM/Server) a partir de Caido y DevTools DOM snapshots.  
2. Herramientas:
   - `dalfox`, `kxss` para automatizar detección. [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)
3. Validación fuerte:
   - DevTools ejecuta payload y confirma ejecución real:
     - Captura de console logs, alert, beacon, etc.  
4. PoC:
   - Petición con payload, instrucciones de navegación, evidencia de pop-up/log en consola.

#### 4.5.3 SSRF

1. Candidatos:
   - Parámetros `url`, `callback`, `image`, `webhook`, etc., detectados con workflows de Caido.  
2. Técnicas:
   - Fuzz de URLs hacia:
     - Dominio de prueba del pentester (out-of-band).  
     - RFC1918 / metadata cloud (limitado por scope/safe_mode).  
3. Validación:
   - Confirmación mediante logs out-of-band (supuesto añadido: servidor de callbacks gestionado por el pentest framework).  
4. PoC:
   - Ejemplo de petición y registro en servidor OOB.

#### 4.5.4 Broken AuthN/AuthZ

1. AuthN
   - Automatización de:
     - Intentos de login con credenciales válidas e inválidas.  
     - DevTools observa respuestas, tokens, cookies.  
   - Casos:
     - Enumeración de usuarios, omisión de MFA, reuso de tokens, sesión no invalidada.

2. AuthZ
   - Uso de múltiples cuentas y roles:
     - DevTools mantiene múltiples contextos de sesión.  
   - Pruebas:
     - Horizontal: acceso de usuario A a recursos B.  
     - Vertical: usuario de bajo privilegio intentando acciones admin.  
   - Validación:
     - Confirmar acceso real a recursos, no sólo mensajes ambiguos.

### 4.6 Análisis de código para “code-aware dynamic testing” (si hay código)

1. MCP Git/Code:
   - Descarga del repo o ruta relevante.  
   - Búsqueda de:
     - Controladores críticos, endpoints admin, paths ocultos, módulos de auth.  
2. Z.ai:
   - Resume riesgos por módulo:
     - Falta de validación, queries construidas dinámicamente, uso de libs inseguras.  
3. Feed-back al dinámico:
   - Genera lista priorizada de rutas/funcionalidades a atacar.  
   - Lanza workflows en Caido y fuzzing focalizado sobre esas rutas.

### 4.7 Correlación, deduplicación, priorización

1. Normalización de findings:
   - Todos los hallazgos (Caido issues, outputs de herramientas, análisis de código) se transforman a estructura estándar.  
2. Correlación:
   - Detección de duplicados (misma URL, parámetro, payload similar).  
3. Prioridad:
   - Basada en:
     - Impacto (CIA, alcance).  
     - Likelihood (facilidad de explotación, pre‑auth vs post‑auth).  
   - Z.ai genera ranking y marca qué PoCs se deben pulir para reporte.

### 4.8 Generación de reporte

1. Z.ai llama a `build_report(session_id)` usando todos los datos normalizados.  
2. Se generan secciones:
   - Ejecutiva.
   - Técnica.
   - PoCs y recomendaciones.  
3. `export_report` produce Markdown y PDF final.

***

5. Herramientas externas, paralelización y “code-aware dynamic testing”
-----------------------------------------------------------------------

### 5.1 Set mínimo de herramientas

- Recon:
  - `subfinder`, `amass` (opcional), `httpx`, `nmap`, `whatweb`. [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)
- Discovery / Fuzz:
  - `ffuf`, `dirsearch` (supuesto añadido).  
- Vulnerabilidades:
  - Injection: `sqlmap`, `nuclei` (plantillas de inyección).  
  - XSS: `dalfox`, `kxss`.  
  - SSRF: scripts propios + `nuclei` SSRF templates.  
  - Auth: scripts personalizados que usan información de DevTools.  
- APIs:
  - `schemathesis` para OpenAPI/GraphQL. [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)

Todas gestionadas a través del MCP CLI-Security.

### 5.2 Orquestación y paralelización

1. **Modelo de colas**
   - Cada tarea es un job con:
     - Tipo (`recon`, `discovery`, `vuln-test`), prioridad, recursos estimados.  
   - Workers especializados:
     - Recon worker, API testing worker, web fuzz worker.

2. **Políticas**
   - Paralelizar:
     - Recon de distintos hosts.
     - Fuzzing de endpoints independientes.  
   - No paralelizar (o limitar):
     - Ataques intensivos a un mismo endpoint (para no DoS).  
   - Configurar `max_parallelism` global y por tool.

3. **Contexto**
   - Cada job reporta:
     - Referencias a session_id, host, endpoint.  
   - Z.ai usa este contexto para interpretar outputs sin perder trazabilidad.

### 5.3 Code-aware dynamic testing

1. A partir del análisis estático:
   - Identificar “hotspots”:
     - Rutas con joins complejos, deserialización, uso de user input sin sanitizar.  
2. Z.ai genera:
   - Lista priorizada de endpoints/dominios.  
   - Estrategias de payload específicas (ej. detectar ORM, framework, libs).  
3. Dinámico:
   - MCP CLI-Security ejecuta herramientas sobre esos endpoints.  
   - Caido workflows se ajustan (por ejemplo, payloads específicos para rutas marcadas como críticas).

***

6. Diseño del reporte “pentester-grade”
--------------------------------------

### 6.1 Estructura general

1. **Portada**
   - Nombre del cliente, target, fechas, versión del reporte.

2. **Resumen ejecutivo**
   - Estado general (riesgo global).
   - Principales vulnerabilidades críticas y su impacto.

3. **Alcance y metodología**
   - Sistemas incluidos/excluidos.
   - Fases realizadas (recon, discovery, explotación, revalidación).  

4. **Matriz de riesgos**
   - Tabla con findings por severidad, impacto, likelihood.

5. **Hallazgos técnicos**
   - Una sección por vulnerabilidad.

### 6.2 Detalle por vulnerabilidad

Para cada finding:

- Identificadores:
  - ID interno, título, categoría OWASP, severidad.  
- Contexto:
  - Afectación funcional (componente, endpoint, roles afectados).  
- Descripción técnica:
  - Breve explicación de la vulnerabilidad en este contexto.  
- Evidencia:
  - Fragmentos de request/response relevantes (sin credenciales sensibles).  
  - Resumen de logs de Caido y outputs de herramientas.  
- PoC:
  - Requests reproducibles:
    - Método, URL, headers, body, notas para ejecutar.  
  - Pasos en navegador:
    - Usando secuencia descrita a partir de DevTools (ej. “1. Navegar a /login, 2. Introducir X, 3. Abrir consola y ejecutar Y”).  
- Impacto:
  - Confidencialidad, integridad, disponibilidad, compliance.  
- Recomendación:
  - Medidas específicas (validación, controles de acceso, hardening).  
- Referencias OWASP:
  - OWASP Top 10 (Injection, XSS, SSRF, Broken Access Control/AuthN).  

Z.ai genera esta sección a partir de la estructura estándar de findings y metadatos.

### 6.3 Anexos

- Listado de hosts, puertos, servicios (de nmap).  
- Listado de endpoints relevantes (de Caido).  
- Evidencias más extensas (logs, capturas).  

***

7. Consideraciones de seguridad, límites y próximos pasos
---------------------------------------------------------

### 7.1 Seguridad y control

1. **Respeto de alcance**
   - Scope configurado en:
     - Proyecto Caido. [caido](https://caido.io/features)
     - Filtros de tools (subfinder, nmap, etc.).  
   - Validador previo en MCP CLI-Security que bloquea comandos fuera de scope.

2. **Rate limiting y carga**
   - Parámetros de safe_mode:
     - Máximo de peticiones por segundo por host.  
     - Límite de threads por herramienta.  
   - Workflows de Caido con reglas para no spamear endpoints sensibles (ej. login). [hackers-arise](https://hackers-arise.com/web-app-hacking-automated-security-workflows-in-caido/)

3. **Protección de producción**
   - Blacklist de métodos destructivos (DELETE/PUT/acciones críticas) salvo autorización explícita.  
   - Uso de payloads “non-destructive” por defecto.

### 7.2 Logging y auditoría

1. Log centralizado:
   - Toda acción del agente (tool invocations, decisiones de Z.ai, cambios de configuración) se registra con:
     - timestamp, actor (agent/tool), parámetros clave, resultado.  
2. Trazabilidad:
   - Cada finding se puede trazar a:
     - Requests concretos de Caido.  
     - Comandos específicos ejecutados vía MCP CLI-Security.  
3. Retención:
   - Política configurable por cliente (ej. 90 días).

### 7.3 Puntos de interrupción manual

Aunque el flujo está diseñado como “fully autonomous”:

1. Breakpoints configurables por fase:
   - Tras recon.
   - Tras primera ronda de pruebas OWASP críticas.
   - Antes de lanzar cualquier exploit potencialmente destructivo.  

2. Modalidad:
   - Modo “semi‑auto” en el que Z.ai propone el siguiente paso y espera confirmación humana.

### 7.4 Próximos pasos de implementación

1. Iteración 1:
   - Backend orquestador básico + MCP CLI-Security.
   - Integración con Z.ai (tools de recon y reporting mínimo).  
2. Iteración 2:
   - MCP Caido (funcionalidad list_projects, get_requests, get_issues, create_issue).  
   - Workflows básicos de Caido para recon pasivo y tagging. [caido](https://caido.io/features)
3. Iteración 3:
   - MCP DevTools y automatización de login/flujos básicos.  
   - Pruebas automáticas para Injection y XSS.  
4. Iteración 4:
   - Extender a SSRF y Broken AuthN/AuthZ complejos.  
   - Integración Git/Code para “code-aware dynamic testing”.  
5. Iteración 5:
   - Refinamiento de reporting, plantillas por cliente, panel de control de sesiones.
